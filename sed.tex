\chapter{SED 编辑器}
\section{ed：Unix世界中的文本编辑\enquote{活化石}}



\begin{wrapfigure}{l}{0.45\textwidth}
	\centering
	\includegraphics[width=0.28\textwidth]{images/thompson}
	\caption{Thompson 2019}
\end{wrapfigure}

在计算机技术飞速发展的今天，众多功能强大、界面友好的文本编辑器层出不穷，但 ed 这个古老的文本编辑器却依然在 Unix 和类 Unix 系统中占有一席之地。它就像一位历经沧桑的老者，见证了操作系统从早期的简陋到如今的复杂多样，其独特的存在意义和价值令人深思。

\subsection{诞生背景与历史地位}

ed 的诞生可以追溯到 1969 年，由 Ken Thompson 在 AT\&T 贝尔实验室的 PDP-7 上开发，它是 Unix 操作系统最初的三个关键组成部分之一，与汇编器、shell 并列。Ken Thompson 在加州大学伯克利分校学习时接触过 qed 文本编辑器，对该编辑器十分熟悉，还将它重新实现到了 CTSS 和 Multics 系统上。qed 的许多特性对 ed 的设计产生了深远影响，尤其是正则表达式的引入，这在当时是一项极具前瞻性的创新，为文本处理开辟了新的可能性。

随着时间推，ed 的影响力不断扩散。Dennis M. Ritchie 对 ed
进行了进一步完善，使其成为后来众多文本编辑器的灵感源泉。例如，ex 编辑器就是在 ed 的基础上发展起来的，而著名的 vi
编辑器又是从 ex 演变而来。非交互式 Unix 命令 grep 的诞生也与 ed 密切相关，它源自 qed 和 ed 中常见的特殊用法，即命令
\shellinline{g/re/p}，用于执行全局正则表达式搜索并打印包含匹配项的行。此外，Unix 流编辑器 sed 实现了 qed 中许多未被 ed 支持的脚本功能，这些都体现了 ed 对 Unix 文化中文本处理工具的深远影响。

\subsection{核心功能与工作原理}

ed 是一个行编辑器，这意味着它主要以行为单位对文本进行操作，而不是像现代的全屏编辑器那样可以直观地查看和编辑整个文本内容。它支持正则表达式，这使得用户能够以强大的模式匹配能力来搜索和替换文本中的特定内容，例如可以通过简单的命令快速找到文本中所有符合特定模式的行，并进行批量修改。

ed 的自动化能力也十分出色，可以通过从标准输入接收命令来实现复杂的文本处理任务。用户可以编写一系列命令，然后将它们传递给 ed，让 ed 自动执行这些命令来完成文本编辑工作，这对于批量处理文本文件非常高效。

然而，ed 也因其简洁到近乎苛刻的交互方式而闻名。它与像 Teletype Model 33 这样的电传打字机终端兼容，几乎不提供任何视觉反馈。当出现错误时，ed 只会显示一个简单的“？”作为提示，而且在用户尝试在未保存更改的情况下退出时，早期版本的 ed 甚至不会要求确认。这种简洁性在早期 Unix 系统中是合理的，因为当时的终端设备速度慢、内存有限，但随着技术的发展，这种交互方式逐渐显得有些过时。

\subsection{实际应用与局限性}

在实际应用中，ed 现在很少被用于交互式编辑。在 20 世纪 80 年代，sam、vi 和 Emacs 等全屏编辑器逐渐流行起来，它们提供了更直观的用户界面和更丰富的功能，使得用户能够更方便地查看和编辑文本。尽管如此，ed 依然在一些 shell 脚本中发挥着重要作用。由于它几乎存在于所有的 Unix 和 Linux 系统中，对于需要在多种 Unix 版本之间工作的用户来说，ed 是一个可靠的备用编辑器。此外，一些工具如 SQL*Plus 在 EDITOR 和 VISUAL 环境变量未定义时，会默认使用 ed 作为编辑器。

ed 的局限性主要体现在其用户交互体验上。它的命令都是单个字母，对于初学者来说很难记住，而且在编辑过程中，用户需要手动输入命令来查看文本内容的变化，这与现代编辑器的即时反馈形成了鲜明对比。不过，GNU 版本的 ed 提供了一些增强反馈的选项，例如使用 ed -v -p: 可以提供简单的提示符和更有用的反馈信息，这在一定程度上改善了用户体验。

\subsection{文化影响与未来展望}

尽管 ed 的使用率不高，但它在计算机文化中却有着独特的地位。GNU 项目在其网站上围绕 ed 开展了许多有趣的笑话，这些笑话反映了 ed 在开发者社区中的特殊地位。同时，glibc 文档中也提到了一个名为 ED 的错误代码，其描述仅为一个问号，这无疑是对 ed 交互风格的一种幽默致敬。

尽管现代文本编辑器不断涌现，但 ed 依然以其独特的简洁性和强大的文本处理能力在 Unix 和类 Unix 系统中占有一席之地。它不仅是 Unix 历史的见证者，也是现代文本编辑器发展的重要基石。在未来，虽然 ed 很可能不会成为主流的交互式文本编辑器，但它在 shell 脚本和特定场景下的应用价值依然不可忽视，它将继续作为 Unix 文化的重要组成部分，为开发者提供一种独特的文本处理方式。


\section{sed：流编辑器的开山鼻祖}
\begin{wrapfigure}{r}{0.5\textwidth}
	\centering
	\includegraphics[width=0.28\textwidth]{images/mcmahon}
	\caption{McMahon}
\end{wrapfigure}


在 Unix 系统的浩渺工具海洋中sed（stream editor）宛如一颗熠熠生辉的明珠，自 1974 年由 Bell Labs 的 Lee E. McMahon 倾心打造后，便凭借其精巧而强大的文本处理能力，成为无数程序员与系统管理员的得力助手，历经岁月洗礼仍屹立不倒，持续在各类操作系统上发光发热。

sed 是一款以行为单位进行文本处理的工具，它从输入流或文件中逐行读取文本，存入内部的模式空间（pattern space），随后依据用户提供的sed 脚本，对每一行文本执行相应的操作sed 脚本由约 25 条命令构成，涵盖了从简单替换到复杂文本结构转换的诸多功能。在默认情况下sed 会在执行完脚本指令后，输出模式空间中的内容，紧接着处理下一行文本，如此循环往复，直至处理完整个输入流。

sed 最为人熟知且频繁使用的功能当属替换命令（\shellinline{s///}）。
\\例如，命令 \shellinline{sed 's/regexp/replacement/g' input > output} 能够将输入文件中符合正则表达式 regexp
的文本替换为 replacement，并将结果输出到指定文件。这里的 \enquote{g} 标志意味着全局替换，即一行中所有匹配的内容都会被替换掉。正则表达式的运用，赋予了sed 强大的模式匹配能力，无论是简单的字符匹配，还是复杂的文本结构识别sed 都能轻松应对。

除了替换功能sed 还能执行诸如删除（d）、追加（a）、插入（i）等多种操作。比如，命令\\ \shellinline{sed '/^ *$/d' input}
可以删除输入文件中仅包含空格或为空的行，这在清理文本数据时极为实用sed 的命令语言虽简洁，却蕴含着强大的功能，甚至具备图灵完备性，能够实现一些复杂的文本处理逻辑，比如通过标签和分支指令实现流程控制，完成类似编程语言中的循环和条件判断操作。

sed
的使用场景极为广泛。在命令行中，可以作为管道的一部分，对其他命令的输出进行即时处理。例如，将某个命令的输出通过管道传递给
sed，快速完成文本格式的转换或数据的初步清洗。此外sed还支持基于文件的脚本运行，用户可以将多个sed
命令写入一个脚本文件，通过 \shellinline{sed -f script input}的方式执行，这种方式不仅便于维护复杂的文本处理逻辑，还能避免命令行中可能出现的转义和替换问题。

GNU sed 的出现为sed 带来了更多新特性，其中最具影响力的是原地编辑（in-place editing）功能。通过 \shellinline{sed -i} 选项，用户可以直接修改文件内容，而无需额外的输出重定向操作，这在批量处理文本文件时极大地提高了效率。此外，还有诸如 Super sed 这样的扩展版本，它增加了与 Perl 兼容的正则表达式，进一步拓展了sed的应用范围。

尽管sed 功能强大，但在面对一些复杂的文本处理任务时，如需对文本进行多行关联分析或执行复杂的文本结构转换，AWK 或 Perl 等更高级的文本处理工具或许是更好的选择。不过sed凭借其简单易用、轻量级的特点，在处理简单文本替换、格式调整等任务时，依然是首选工具，它的语法和设计理念也对后续诸多文本处理工具和编程语言产生了深远影响。

\section{sed的工作流程}
sed（stream editor，流编辑器）是一种面向行的文本处理工具，其核心设计理念是对输入流逐行处理、单次遍历、高效转换。它的工作流程遵循以下原理：

1. 读取输入：sed 从标准输入或指定文件中按行读取文本。每一行去掉行末的\shellinline{\n}被读入一个称为模式空间（pattern space）的内部缓冲区。

2. 执行脚本命令：对于模式空间中的当前行，sed 按顺序执行用户提供的编辑命令（如替换 \shellinline{s///}、删除
\shellinline{d}、打印 \shellinline{p} 等）。这些命令可以基于行号、正则表达式或地址范围进行条件匹配。

3. 自动输出（默认）：在处理完当前行的所有命令后，若未使用 \shellinline{-n} 选项，sed
会自动将模式空间的内容加上\shellinline{\n}输出到标准输出。

4. 清空并进入下一行：输出完成后，模式空间被清空（除非使用 \shellinline{D} 或 \shellinline{N} 等特殊命令保留内容），然后读取下一行，重复上述过程，直到输入结束。

此外，sed 还维护一个称为暂存空间（hold space）的辅助缓冲区，可通过
\shellinline{h}、\shellinline{H}、\shellinline{g}、\shellinline{G}、\shellinline{x} 等命令在模式空间与暂存空间之间传递数据，实现跨行处理（如合并多行、反向输出等复杂操作）。

由于 sed 只对输入进行一次顺序扫描，不回溯、不加载全文到内存，因此特别适合在管道中高效处理大型文本流，是 Unix/Linux 文本自动化处理的重要工具之一。


\section{sed的选项及命令概览}
表\ref{tab:sed-options}列出了sed的全部选项，其中常用的有\shellinline{-n}、\shellinline{-f}、\shellinline{-i}、\shellinline{-e}、\shellinline{-r}。
\begin{table}[htbp]
	\centering
	\footnotesize
	\begin{tabular}{l l}
		\toprule
		\textbf{选项}                                        & \textbf{说明}                               \\\midrule
		\texttt{-n}, \texttt{--quiet}, \texttt{--silent}     & 禁止自动打印模式空间内容。                  \\
		\texttt{-e script}, \texttt{--expression=script}     & 将指定脚本添加到要执行的命令列表中。        \\
		\texttt{-f script-file}, \texttt{--file=script-file} & 从文件中读取 sed 脚本并执行。               \\
		\texttt{-i[SUFFIX]}, \texttt{--in-place[=SUFFIX]}    & 直接修改文件；若提供 SUFFIX，则备份原文件。 \\
		\texttt{-l N}, \texttt{--line-length=N}              & 指定 \texttt{l} 命令输出时的换行宽度。      \\
		\texttt{--posix}                                     & 禁用所有 GNU 扩展，仅使用 POSIX 标准功能。  \\
		\texttt{-E}, \texttt{-r}, \texttt{--regexp-extended} & 使用扩展正则表式（ERE）。                   \\
		\texttt{-s}, \texttt{--separate}                     & 将多个输入文件视为独立流，而非一个连续流。  \\
		\texttt{--sandbox}                                   & 启用沙箱模式，禁用 \texttt{e/r/w} 等命令。  \\
		\texttt{-u}, \texttt{--unbuffered}                   & 最小化读取输入，并更频繁地刷新输出缓冲区。  \\
		\texttt{-z}, \texttt{--null-data}                    & 使用 NUL 字符（而非换行符）作为行分隔符。   \\
		\texttt{--follow-symlinks}                           & 在就地编辑（\texttt{-i}）时跟随符号链接。   \\
		\texttt{--version}                                   & 输出版本信息并退出。                        \\
		\texttt{--help}                                      & 显示帮助信息并退出。                        \\
		\bottomrule
	\end{tabular}
	\caption{sed 命令行选项}
	\label{tab:sed-options}
\end{table}

表\ref{tab:sed-commands}列出了sed的全部脚本命令，其中常用的有\shellinline{s}、\shellinline{p}、\shellinline{d}、\shellinline{a}、\shellinline{i}、\shellinline{c}，而其他一些命令涉及到多行、暂存空间处理属于高级命令。
\begin{table}[htbp]
	\centering
	\footnotesize
	\begin{tabular}{ll}\toprule
		\textbf{命令}                  & \textbf{说明}                                                                                     \\\midrule
		\texttt{:label}                & 定义一个标签，供 \texttt{b} 或 \texttt{t} 命令跳转。                                              \\
		\texttt{\#comment}             & 注释，直到行尾（或 \texttt{-e} 脚本片段结束）。                                                   \\
		\texttt{\{} / \texttt{\}}      & 开始 / 结束命令块。                                                                               \\
		\texttt{=}                     & 打印当前行号。                                                                                    \\
		\texttt{a\textbackslash text}  & 在当前行后追加文本（多行需用反斜杠转义换行）。                                                    \\
		\texttt{i\textbackslash text}  & 在当前行前插入文本（多行需用反斜杠转义换行）。                                                    \\
		\texttt{q [exit-code]}         & 立即退出 sed 脚本（GNU 扩展支持退出码）。                                                         \\
		\texttt{Q [exit-code]}         & 立即退出且不打印当前模式空间（GNU 扩展）。                                                        \\
		\texttt{r filename}            & 从文件末尾读取内容并追加到输出。                                                                  \\
		\texttt{R filename}            & 每次调用读取文件的一行并追（GNU 扩展）。                                                          \\
		\texttt{b [label]}             & 无条件跳转到指定标签（省略则跳至脚本末尾）。                                                      \\
		\texttt{c\textbackslash text}  & 用指定文本替换匹配的行（多行需转义）。                                                            \\
		\texttt{d}                     & 删除模式空间，开始下一轮循环。                                                                    \\
		\texttt{D}                     & 删除模式空间中第一个换行符前的内容，不读新行继续处理。                                            \\
		\texttt{h}                     & 将模式空间复制到暂存空间（hold space）。                                                          \\
		\texttt{H}                     & 将模式空间追加到暂存空间。                                                                        \\
		\texttt{g}                     & 将暂存空间复制到模式空间。                                                                        \\
		\texttt{G}                     & 将暂存空间追加到模式空间。                                                                        \\
		\texttt{l}                     & 以“视觉明确”方式列出当前行（含不可见字符）。                                                      \\
		\texttt{l width}               & 同上，但指定每行最大宽度（GNU 扩展）。                                                            \\
		\texttt{n}                     & 读取下一行到模式空间（可能触发自动打印）。                                                        \\
		\texttt{N}                     & 将下一行追加到模式空间（保留换行符）。                                                            \\
		\texttt{p}                     & 打印整个模式空间。                                                                                \\
		\texttt{P}                     & 仅打印模式空间中第一个换行符前的内容。                                                            \\
		\texttt{s/regexp/replacement/} & 替换匹配正则表达式的部分；可用 \texttt{\&} 和 \texttt{\textbackslash1}–\texttt{\textbackslash9}。 \\
		\texttt{t [label]}             & 若上次 \texttt{s} 成功，则跳转（GNU 扩展支持标签）。                                              \\
		\texttt{T [label]}             & 若上次 \texttt{s} 未成功，则跳转（GNU 扩展）。                                                    \\
		\texttt{w filename}            & 将当前模式空间写入文件。                                                                          \\
		\texttt{W filename}            & 将模式空间第一行写入文件（GNU 扩展）。                                                            \\
		\texttt{x}                     & 交换模式空间与暂存空间的内容。                                                                    \\
		\texttt{y/source/dest/}        & 字符逐位映射转换（类似 \texttt{tr}）。
		\\\bottomrule
	\end{tabular}
	\caption{sed 脚本命令}
	\label{tab:sed-commands}
\end{table}

\section{常用用法}
替换命令\shellinline{s}应该是sed最为人所知也最常用的功能，而其经典的语法\shellinline{s/old/new/}也深刻的影响后来的Vim等软件。下面我们就来演示一下基本的用法。
\begin{shellcmd}[label={sub:simple}]
$> echo "hello world" | sed 's/world/tomorrow/'
hello tomorrow
\end{shellcmd}
示例\ref{sub:simple}会扫描每一行，并进行替换。

\begin{shellcmd}[label={sub:lineno}]
$> echo "hello\nworld" | sed '2s/world/there/'
hello
there
\end{shellcmd}
示例\ref{sub:lineno}中首先会确认行号是不是2，确认后才会进行替换。

\begin{shellcmd}[label={sub:delimiter1}]
$> echo $HOME | sed 's/\//\\/'
\Users/dax
\end{shellcmd}
示例\ref{sub:delimiter1}中，因为\shellinline{/}是替换命令的界定符，所以要替换其本身的时候需要进行转义。字符的转义都要用\shellinline{\ }。

\begin{shellcmd}[label={sub:delimiter2}]
$> echo $HOME | sed 's:/:\\:'
\Users/dax
\end{shellcmd}
示例\ref{sub:delimiter1}中的写法比较麻烦，可读性差，所以遇到这种情况的时候，一般会改用其他界定符。

\begin{shellcmd}[label={sub:labelg}]
$> echo $HOME | sed 's:/:\\:g'
\Users\dax
\end{shellcmd}
示例\ref{sub:delimiter1}和\ref{sub:delimiter2}中只替换了第一个匹配，如果需要替换全部，则需要用到\shellinline{g}标签。

\begin{shellcmd}[label={sub:labeln}]
$> echo $HOME | sed 's:/:\\:2'
/Users\dax
\end{shellcmd}
也可以像示例\ref{sub:labeln}中一样指定替换第\shellinline{n}个匹配。
\begin{shellcmd}[label={sub:labelng}]
$> echo "hello world" | sed 's/l/x/2g'
helxo worxd
\end{shellcmd}
将\shellinline{g}标签和\shellinline{n}标签结合，实现示例\ref{sub:labelng}中从\shellinline{n}到最后一个的替换。

除了从\shellinline{stdin}输入，也可以直接从文件输入内容。
\begin{shellcmd}
$> cat sample.txt
apple banana cherry
dog elephant frog
hello world hello
123 456 789
The quick brown fox jumps over the lazy dog.
HELLO WORLD!
test@example.com
line with   extra   spaces
\end{shellcmd}
\begin{shellcmd}
$> sed 's/hello/HELLO/g' sample.txt
apple banana cherry
dog elephant frog
HELLO world HELLO
123 456 789
The quick brown fox jumps over the lazy dog.
HELLO WORLD!
test@example.com
line with   extra   spaces
\end{shellcmd}

sed默认会打印所有的行，\shellinline{-n}选项可以关闭，然后用\shellinline{p}命令来打印匹配的行。
\begin{shellcmd}
$> sed -n 's/hello/HELLO/gp' sample.txt
HELLO world HELLO
\end{shellcmd}

如果需要用到多个命令，可以用\shellinline{-e}选项。
\begin{shellcmd}
$> sed -n -e 's/hello/HELLO/g' -e 's/world/there/gp' sample.txt
HELLO there HELLO
\end{shellcmd}

多个命令也可以用\shellinline{;}来分隔。
\begin{shellcmd}
$> sed -n 's/hello/HELLO/g;s/world/there/gp' sample.txt
HELLO there HELLO
\end{shellcmd}

对于比较复杂的多个命令，我们可以将指令写在一个文件里面，然后用\shellinline{-f}选项来加载。
\begin{shellcmd}
$> cat script.sed
s/hello/HELLO/g
s/world/there/gp
\end{shellcmd}
\begin{shellcmd}
$> sed -n -f script.sed sample.txt
HELLO there HELLO
\end{shellcmd}

修改的结果我们可以用从\shellinline{stdout}重新定向（redirect）到文件。
\begin{shellcmd}
$> sed -n -f script.sed sample.txt > temp.txt
\end{shellcmd}


用\shellinline{-i}可以实现原地修改，但是这个比较危险，使用之前要确认修改的内容是你想要的。
\begin{shellcmd}
$> sed -n -i -f script.sed sample.txt
\end{shellcmd}

最好是用个备份，用\shellinline{-isuffix}或者\shellinline{--in-place=suffix}，我觉得后者更加易读些。
\begin{shellcmd}
$> sed -n -ibak -f script.sed sample.txt
\end{shellcmd}
\begin{shellcmd}
$> sed -n --in-place=bak -f script.sed sample.txt
\end{shellcmd}
注意一般长的选项前面加\shellinline{--}，而短的则加\shellinline{-}。

另外一个常用的命令是删除\shellinline{d}。
\begin{shellcmd}
$> sed '1d' sample.txt
dog elephant frog
hello world hello
123 456 789
The quick brown fox jumps over the lazy dog.
HELLO WORLD!
test@example.com
line with   extra   spaces
\end{shellcmd}
\shellinline{1d}是作用是删除第一行。
